/*
 * matrix_multiplication_component.hpp
 *
 *  Created on: Sep 5, 2016
 *      Author: pfandedd
 */

#pragma once

#include <cinttypes>
#include <hpx/include/components.hpp>
#include <hpx/include/iostreams.hpp>

#include "matrix_multiply_kernel.hpp"

extern uint64_t small_block_size;
extern uint64_t verbose;

struct matrix_multiply_node: hpx::components::component_base<
		matrix_multiply_node> {

	size_t N;
	std::vector<double> A;
	std::vector<double> B;
	std::vector<double> C;

	// TODO: why does this get called?
	matrix_multiply_node() :
			N(0) {
	}

	matrix_multiply_node(size_t N, std::vector<double> A,
			std::vector<double> B) :
			N(N), A(A), B(B) {
	}

	std::vector<double> matrix_multiply(std::uint64_t x, std::uint64_t y,
			size_t blockSize);

	void extract_submatrix(std::vector<double> C_small, size_t x,
			size_t y, size_t blockSize);

	HPX_DEFINE_COMPONENT_ACTION(matrix_multiply_node, matrix_multiply,
			matrix_multiply_action);

	HPX_DEFINE_COMPONENT_ACTION(matrix_multiply_node, extract_submatrix,
			extract_submatrix_action);

};

HPX_REGISTER_ACTION_DECLARATION(matrix_multiply_node::matrix_multiply_action);

//// use autogenerated -> remove, then use async
//struct matrixMultiply_client: hpx::components::client_base<
//		matrixMultiply_client, matrixMultiply_server> {
//
//	using base_type = hpx::components::client_base<
//	matrixMultiply_client, matrixMultiply_server>;
//
//	matrixMultiply_client(const hpx::naming::id_type& id): base_type(id) {
//
//	}
//
//	matrixMultiply_client(hpx::future<hpx::id_type> && id) :
//			base_type(std::move(id)) {
//	}
//
//	hpx::future<std::vector<double>> matrixMultiplyClient(std::uint64_t x,
//			std::uint64_t y, size_t blockSize) {
//		return hpx::async<matrixMultiply_server::matrixMultiply_action>(
//				get_id(), x, y, blockSize);
//	}
//};

